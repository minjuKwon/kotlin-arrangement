1. 자바
1)상수 사용법
- 인터페이스에 상수인 public static final으로 정의 가능
- 모든 필드는 암묵적으로 public static final
- 값을 인터페이스에 직접 저장 가능


2)사용 이유
- 인터페이스를 상수 모음처럼 사용하는 관행 존재
- 공통적으로 사용할 상수 값을 일관되게 공유하기 위해 제공
- 클래스 로딩 시점에 메모리에 올라가는 정적(static) 상수
- 하지만 객체 지향 원칙에 어긋나는 설계로, 이후에는 권장되지 않는 방식


3)예제코드
interface MyInterface {
    int CONSTANT = 42;
}



2. 코틀린
1)상수 사용 불가능
- 코틀린은 인터페이스를 상태 없는 추상 행위 집합으로 설계
- 인터페이스는 필드(상태)를 가질 수 없기 때문에 허용되지 않음
- 행위만 정의라는 철학을 지키기 위한 제한
- val
  - 정의는 가능하지만 값 보유 불가능. 추상 프로퍼티로써 선언됨
  - 값을 저장하지 않고 getter 함수 시그니처만 정의
  - 구현체가 해당 값을 제공
- var
  - var 선언 불가능
  - 보조 필드가 필요하기에 사용 불가능
  - set() 사용을 아예 막아놓음
- const val
  - const val 선언 불가
  - 컴파일 타임 상수이기에 필드 생성이 가능한 곳에만 정의 가능


2)상수 사용법
- companion object 내부에 정의 가능
- 인터페이스 내부의 독립 객체이므로 상태 보유 가능
- 제한이 완화된 게 아니라 위치가 다르기 때문에 가능
- 객체니까 상태와 상수를 포함 가능


3)메서드
- 코틀린에서는 인터페이스 안에 메서드 구현 가능
- 상태를 저장하지 않고 동작만 포함하므로 허용
- 자바 8의 default method와 유사한 구조


4)예제코드
interface MyInterface {
    // const val CONSTANT = 42 // 불가

    companion object {
        const val CONSTANT = 42 // 가능
    }
 fun run() {
        println("실행")
    }
}