1. 자바
인터페이스에 public static final 상수 정의 가능
모든 필드는 암묵적으로 public static final이므로, 값을 인터페이스에 직접 저장 가능
인터페이스를 상수 모음처럼 사용하는 관행 존재. 공통적으로 사용할 상수 값을 일관되게 공유하기 위해 제공
그래서 public static final 필드를 인터페이스에 정의할 수 있도록 허용
이 값들은 클래스 로딩 시점에 메모리에 올라가는 정적(static) 상수
하지만 이것은 객체 지향 원칙에 어긋나는 설계로, 이후에는 권장되지 않는 방식
interface MyInterface {
    int CONSTANT = 42;
}


2. 코틀린
인터페이스에는 const val 선언 불가. 코틀린은 인터페이스를 상태 없는 추상 행위 집합으로 설계. 행위만 정의라는 철학을 지키기 위한 제한.
const val은 컴파일 타임 상수이기 때문에, 필드 생성이 가능한 곳에만 정의 가능.
인터페이스는 필드(상태)를 가질 수 없기 때문에 허용되지 않음.
val을 사용해 프로퍼티를 정의할 수 있지만, 이는 getter만 가진 추상 프로퍼티이고 값을 저장하지 않음 직접 가지기 보다 return역할
var에서는 보조 필드가 필요하기에 사용 불가능. set() 사용을 아예 막아놓음
대신 companion object 내부에 정의 가능. 인터페이스 내부의 독립 객체이므로 상태 보유 가능. 즉, 제한이 완화된 게 아니라 위치가 다르기 때문에 가능한 것. 객체니까 상태와 상수를 포함할 수 있음

interface MyInterface {
    // const val CONSTANT = 42 // 불가

    companion object {
        const val CONSTANT = 42 // 가능
    }
}


코틀린에서는 인터페이스 안에 메서드 구현 가능.
상태를 저장하지 않고 동작만 포함하므로 허용됨.
이는 자바 8의 default method와 유사한 구조.
interface MyInterface {
    fun run() {
        println("실행")
    }
}
