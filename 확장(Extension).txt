1. 기본 개념
- 클래스 상속이나 Decorator와 같은 디자인 패턴을 사용하지 않고도 기존 클래스나 인터페이스의 기능을 확장할 수 있는 개념. 기존의 클래스에 내가 원하는 함수나 프로퍼티를 하나 더 포함시켜 확장하고 싶을 때 사용. 즉, 필요로 하는 대상에 함수나 프로퍼티 추가 가능. 
- 확장 기법을 사용하면 기존 클래스의 선언부나 구현부를 수정하지 않고 외부에서 손쉽게 기능을 확장 가능. 기존의 표준 라이브러리를 수정하지 않고도 확장할 수 있는 유용한 기법. 
- 코틀린은 클래스가 기본적으로 final이라서 open 키워드를 별도로 표시하지 않으면 상속 불가능. 상속 대신 기능 확장 가능
- 코틀린의 최상위 클래스는 Any이기 때문에 Any 클래스에 확장을 정의한다면 모든 클래스에서 사용 가능
- 기존 클래스의 멤버처럼 호출할 수 있는 높은 가독성. 기존 클래스의 수정이 없는 유연한 확장성	



2. 특징
1)동작 방식
- 확장을 정의해도 실제 클래스에 메서드나 프로퍼티 추가를 의미X
- 객체 내부에 값을 저장할 수 없으므로 일회성처럼 동작


2)스코프와 사용 조건
- 확장 함수를 정의해도 명시적으로 import 해야 다른 파일에서 사용 가능함
- 전역처럼 사용 불가능


3)접근 제한자 제한
- public 멤버에만 접근 가능.
- private 또는 protected 멤버에는 접근 불가. 이런 경우에는 클래스 내부 멤버로 구현 필요


4)this 키워드의 의미
- 확장 내부의 this는 수신 객체(receiver object)를 의미
- 확장은 수신 타입(receiver type)을 기반으로 정의. this는 해당 타입의 인스턴스를 가리킴.


5)멤버와의 우선순위
- 동일한 이름의 멤버 함수가 클래스에 존재할 경우, 확장 함수보다 멤버 함수가 우선 호출. 프로퍼티도 동일
- 확장 프로퍼티를 정의할 때는 반드시 getter 정의 필요


6)상속과 오버라이딩 제한
- 확장 함수는 상속 불가
- 하위 클래스에서 확장 함수를 오버라이딩 불가
- 단, 같은 함수 이름으로 오버로드(다중 정의)는 가능


7)바인딩 방식 차이
- 일반 멤버는 동적 바인딩. 런타임에 호출 함수 결정.
- 확장은 정적 바인딩. 컴파일 시점에 호출 함수 결정.


8)Companion Object 확장 가능
- 클래스의 companion object에도 확장 함수 정의 가능


9)제네릭 타입 확장 가능
- 제네릭 클래스에 대해서도 확장 함수 정의 가능
- MutableList<Int> 대신 MutableList<T>로 범용 처리 가능



3. 사용법
1)클래스 확장
특히 컬렉션. 일급 컬렉션


2)문자열
검사/처리


3)Nullable타입
null처리


4)고차함수와 함께 사용


5)외부 라이브러리 확장


6)바인딩 어댑터 확장


7)안드로이드
안드로이드에서 사용할 수 있는 유용한 사용법에 대해 설명하는 블로그 주소

- https://best-coding.tistory.com/m/76
- https://dongx2.tistory.com/123
